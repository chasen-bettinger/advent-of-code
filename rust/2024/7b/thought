190: 10 19
3267: 81 40 27
83: 17 5
156: 15 6
7290: 6 8 6 15
161011: 16 10 13
192: 17 8 14
21037: 9 7 18 13
292: 11 6 16 20




81 40 27 

A: (+, *) - 4
[+, +]
[+, *]
[*, +]
[*, *]

B: (+, *, ||) - 9
[+, +]
[+, *]
[*, +]
[*, *]
[||, +]
[||, *]
[||, ||]
[+, ||]
[*, ||]

///

9 7 18 13 (8)
[+, +, +]

[+, *, +]
[+, *, *]
[+, +, *]
--
[*, +, +]
[*, *, +]
[*, +, *]

[*, *, *]

///

5 28 41 55 3 (16)
[+, +, +, +]

[+, *, *, *]
[+, +, *, *]
[+, +, +, *]
[+, +, *, +]
[+, *, +, *]
[+, *, *, +]
[+, *, +, +]
--
[*, +, +, +]
[*, *, +, +]
[*, *, *, +]
[*, +, +, *]
[*, *, +, *]
[*, +, *, *]
[*, +, *, +]

[*, *, *, *]




2: 4
3: 8
4: 

// 0111 = 7
// 1000 = 8
let k = 0111 & 1000;
assert_eq!(k, 0000);

why does k = 104?

0111 in octal = 73 
1000 


Ah, this is a common source of confusion! In Rust (and many other programming languages), when you write a number with a leading `0`, it's interpreted as an octal (base-8) number, not decimal or binary.

Why must iterators retain internal state?
